<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Floor Plan Layout (to-scale, mm)</title>
    <style>
      :root {
        --bg: #0b0c10;
        --panel: #151823;
        --ink: #e8e8ea;
        --muted: #aab0c0;
        --grid: rgba(255, 255, 255, 0.1);
        --outline: rgba(255, 255, 255, 0.6);
        --open: rgba(120, 210, 120, 0.35);
        --wall: rgba(255, 255, 255, 0.9);

        --sofa: rgba(70, 130, 180, 0.55);
        --bbq: rgba(220, 80, 80, 0.55);
        --chair: rgba(190, 160, 90, 0.55);
        --coffee: rgba(180, 180, 180, 0.55);
        --side: rgba(140, 210, 220, 0.55);
        --pier: rgba(100, 100, 100, 0.8);
      }

      body {
        margin: 0;
        background: var(--bg);
        color: var(--ink);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial,
          sans-serif;
      }

      header {
        padding: 14px 16px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.06),
          rgba(255, 255, 255, 0)
        );
      }

      h1 {
        margin: 0;
        font-size: 16px;
        letter-spacing: 0.2px;
      }

      .sub {
        margin-top: 6px;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.35;
      }

      .wrap {
        display: grid;
        grid-template-columns: 380px 1fr;
        gap: 12px;
        padding: 12px;
      }

      @media (max-width: 900px) {
        .wrap {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        padding: 12px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      .controls label {
        display: block;
        margin: 10px 0 6px;
        color: var(--muted);
        font-size: 12px;
      }

      .controls input[type='range'] {
        width: 100%;
      }

      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      button {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.16);
        color: var(--ink);
        padding: 8px 10px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
        font-size: 13px;
      }

      button:hover {
        background: rgba(255, 255, 255, 0.12);
      }

      button.danger {
        border-color: rgba(220, 80, 80, 0.5);
        color: #ff6b6b;
      }

      button.danger:hover {
        background: rgba(220, 80, 80, 0.2);
      }

      button.active {
        background: rgba(100, 180, 255, 0.3);
        border-color: rgba(100, 180, 255, 0.6);
      }

      .legend {
        margin-top: 10px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.5;
      }

      .legend .sw {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 3px;
        margin-right: 8px;
        vertical-align: -2px;
        border: 1px solid rgba(255, 255, 255, 0.25);
      }

      .stage {
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        overflow: hidden;
        position: relative;
        min-height: 1220px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }

      .stage-inner {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 10px;
      }

      /* Fit SVG nicely */
      svg {
        max-width: 100%;
        max-height: calc(100vh - 180px);
        height: auto;
        width: auto;
        background: rgba(255, 255, 255, 0.02);
        border-radius: 10px;
      }

      .hint {
        margin-top: 10px;
        color: var(--muted);
        font-size: 12px;
      }

      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          'Liberation Mono', monospace;
      }

      .section-title {
        font-weight: 600;
        margin: 16px 0 8px;
        padding-top: 12px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .section-title:first-child {
        margin-top: 0;
        padding-top: 0;
        border-top: none;
      }

      .item-row {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      }

      .item-row:last-child {
        border-bottom: none;
      }

      .item-color {
        width: 24px;
        height: 24px;
        border-radius: 4px;
        border: 1px solid rgba(255, 255, 255, 0.25);
        cursor: pointer;
        padding: 0;
      }

      .item-name {
        flex: 1;
        font-size: 12px;
      }

      .item-dims {
        font-size: 11px;
        color: var(--muted);
        font-family: monospace;
      }

      .item-actions {
        display: flex;
        gap: 4px;
      }

      .item-actions button {
        padding: 4px 8px;
        font-size: 11px;
      }

      .layout-select {
        width: 100%;
        padding: 8px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.16);
        color: var(--ink);
        border-radius: 8px;
        font-size: 13px;
      }

      .layout-select option {
        background: var(--panel);
      }

      input[type='text'],
      input[type='number'] {
        padding: 8px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.16);
        color: var(--ink);
        border-radius: 8px;
        font-size: 13px;
      }

      input[type='color'] {
        width: 40px;
        height: 32px;
        padding: 2px;
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 6px;
        cursor: pointer;
      }

      .add-item-form {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 8px;
      }

      .add-item-form input[type='text'] {
        grid-column: 1 / -1;
      }

      .add-item-form .full-width {
        grid-column: 1 / -1;
      }

      .hidden-item {
        opacity: 0.4;
      }

      .scroll-panel {
        max-height: 300px;
        overflow-y: auto;
        margin: 8px 0;
        padding-right: 4px;
      }

      .scroll-panel::-webkit-scrollbar {
        width: 6px;
      }

      .scroll-panel::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 3px;
      }

      .scroll-panel::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
      }

      /* Floor Plan Image Styles */
      .floorplan-controls {
        margin-top: 8px;
      }

      .floorplan-controls input[type='file'] {
        display: none;
      }

      .floorplan-controls .file-label {
        display: inline-block;
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid rgba(255, 255, 255, 0.16);
        border-radius: 8px;
        cursor: pointer;
        font-size: 13px;
        font-weight: 600;
      }

      .floorplan-controls .file-label:hover {
        background: rgba(255, 255, 255, 0.12);
      }

      .calibration-info {
        margin-top: 8px;
        padding: 8px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 6px;
        font-size: 11px;
      }

      .calibration-info.active {
        background: rgba(100, 180, 255, 0.15);
        border: 1px solid rgba(100, 180, 255, 0.3);
      }

      .calibration-status {
        color: var(--muted);
        margin-bottom: 4px;
      }

      .calibration-status.calibrated {
        color: #7ddc7d;
      }

      .floorplan-item {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 8px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 6px;
        margin-bottom: 6px;
      }

      .floorplan-item .fp-name {
        flex: 1;
        font-size: 12px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .floorplan-item .fp-actions {
        display: flex;
        gap: 4px;
      }

      .floorplan-item .fp-actions button {
        padding: 4px 8px;
        font-size: 11px;
      }

      .slider-row {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .slider-row input[type='range'] {
        flex: 1;
      }

      .slider-row .slider-value {
        min-width: 45px;
        text-align: right;
        font-size: 12px;
        color: var(--muted);
        font-family: monospace;
      }

      .dimensions-form {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
        margin-top: 8px;
      }

      .dimensions-form .full-width {
        grid-column: 1 / -1;
      }

      /* Modal for calibration */
      .modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 1000;
        place-items: center;
      }

      .modal-overlay.show {
        display: grid;
      }

      .modal {
        background: var(--panel);
        border: 1px solid rgba(255, 255, 255, 0.15);
        border-radius: 12px;
        padding: 20px;
        max-width: 400px;
        width: 90%;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      }

      .modal h3 {
        margin: 0 0 12px;
        font-size: 16px;
      }

      .modal p {
        margin: 0 0 16px;
        color: var(--muted);
        font-size: 13px;
        line-height: 1.5;
      }

      .modal input[type='number'] {
        width: 100%;
        margin-bottom: 12px;
        box-sizing: border-box;
      }

      .modal .modal-buttons {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Floor Plan Layout Planner (to-scale in millimetres)</h1>
      <div class="sub">
        Load a floor plan image and calibrate it to real-world scale. Drag
        furniture to reposition.
        <span class="mono">(0,0) is bottom-left.</span>
      </div>
    </header>

    <div class="wrap">
      <aside class="card controls">
        <div
          class="section-title"
          style="border-top: none; padding-top: 0; margin-top: 0"
        >
          <strong>üìê Floor Plan Image</strong>
        </div>
        <div class="floorplan-controls">
          <input type="file" id="floorplanInput" accept="image/*" />
          <label for="floorplanInput" class="file-label">üìÅ Load Image</label>
          <div class="row">
            <button id="calibrateBtn">üìè Calibrate Scale</button>
            <button id="clearFloorplanBtn" class="danger">Clear Image</button>
          </div>
          <div id="calibrationInfo" class="calibration-info">
            <div id="calibrationStatus" class="calibration-status">
              No floor plan loaded
            </div>
            <div id="calibrationDetails"></div>
          </div>
          <label>Image Opacity</label>
          <div class="slider-row">
            <input
              id="floorplanOpacity"
              type="range"
              min="0.1"
              max="1"
              step="0.05"
              value="0.5"
            />
            <span id="opacityValue" class="slider-value">50%</span>
          </div>
        </div>

        <div class="section-title"><strong>üìÅ Saved Floor Plans</strong></div>
        <div
          id="floorplansList"
          class="scroll-panel"
          style="max-height: 150px"
        ></div>

        <div class="section-title"><strong> View Controls</strong></div>
        <label for="zoom">Zoom</label>
        <input
          id="zoom"
          type="range"
          min="0.25"
          max="2.5"
          step="0.05"
          value="0.75"
        />

        <div class="row">
          <button id="reset">Reset positions</button>
          <button id="snap">Snap to 50mm</button>
          <button id="toggleGrid">Toggle grid</button>
          <button id="toggleFloorplan">Toggle floor plan</button>
        </div>

        <div class="hint">
          Double-click furniture to rotate 90¬∞ (if rotatable).
        </div>

        <div class="section-title"><strong>üíæ Layouts</strong></div>
        <select id="layoutSelect" class="layout-select">
          <option value="">-- Select a layout --</option>
        </select>
        <div class="row">
          <button id="saveLayout">Save Current</button>
          <button id="saveAsLayout">Save As New</button>
          <button id="deleteLayout" class="danger">Delete</button>
        </div>

        <div class="section-title"><strong>ü™ë Furniture Items</strong></div>
        <div id="itemsList" class="scroll-panel"></div>

        <div class="section-title"><strong>‚ûï Add New Item</strong></div>
        <div class="add-item-form">
          <input type="text" id="newItemName" placeholder="Item name" />
          <input
            type="number"
            id="newItemWidth"
            placeholder="Width (mm)"
            min="100"
          />
          <input
            type="number"
            id="newItemHeight"
            placeholder="Height (mm)"
            min="100"
          />
          <div style="display: flex; align-items: center; gap: 8px">
            <label style="margin: 0; font-size: 12px">Color:</label>
            <input type="color" id="newItemColor" value="#4682b4" />
          </div>
          <div style="display: flex; align-items: center; gap: 8px">
            <label style="margin: 0; font-size: 12px">
              <input type="checkbox" id="newItemCircle" /> Circle
            </label>
          </div>
          <button id="addItem" class="full-width">Add Item</button>
        </div>
      </aside>

      <main class="stage">
        <div class="stage-inner">
          <svg
            id="svg"
            viewBox="0 0 3000 5400"
            xmlns="http://www.w3.org/2000/svg"
            aria-label="Floor plan (mm)"
          >
            <defs>
              <pattern
                id="grid100"
                width="100"
                height="100"
                patternUnits="userSpaceOnUse"
              >
                <path
                  d="M 100 0 L 0 0 0 100"
                  fill="none"
                  stroke="var(--grid)"
                  stroke-width="1"
                />
              </pattern>
              <pattern
                id="grid50"
                width="50"
                height="50"
                patternUnits="userSpaceOnUse"
              >
                <path
                  d="M 50 0 L 0 0 0 50"
                  fill="none"
                  stroke="rgba(255,255,255,0.06)"
                  stroke-width="1"
                />
              </pattern>

              <filter id="shadow" x="-30%" y="-30%" width="160%" height="160%">
                <feDropShadow
                  dx="0"
                  dy="10"
                  stdDeviation="12"
                  flood-color="#000"
                  flood-opacity="0.35"
                />
              </filter>
            </defs>

            <g id="world" transform="translate(0,5400) scale(1,-1)">
              <g id="gridLayer">
                <rect
                  x="0"
                  y="0"
                  width="3000"
                  height="5400"
                  fill="url(#grid50)"
                />
                <rect
                  x="0"
                  y="0"
                  width="3000"
                  height="5400"
                  fill="url(#grid100)"
                />
              </g>

              <!-- Floor plan image layer (after grid so it shows on top) -->
              <g id="floorplanLayer" transform="scale(1,-1) translate(0,-5400)">
                <image
                  id="floorplanImage"
                  x="0"
                  y="0"
                  width="3000"
                  height="5400"
                  preserveAspectRatio="none"
                  opacity="0.5"
                />
              </g>

              <rect
                id="canvasBorder"
                x="0"
                y="0"
                width="3000"
                height="5400"
                fill="none"
                stroke="var(--outline)"
                stroke-width="12"
              />

              <!-- Calibration line overlay -->
              <g id="calibrationLayer" style="display: none">
                <line
                  id="calibrationLine"
                  x1="0"
                  y1="0"
                  x2="0"
                  y2="0"
                  stroke="#ff6b6b"
                  stroke-width="8"
                  stroke-dasharray="20,10"
                />
                <circle
                  id="calibrationStart"
                  r="20"
                  fill="#ff6b6b"
                  cx="0"
                  cy="0"
                  style="display: none"
                />
                <circle
                  id="calibrationEnd"
                  r="20"
                  fill="#ff6b6b"
                  cx="0"
                  cy="0"
                  style="display: none"
                />
                <g id="calibrationLabelGroup" transform="scale(1,-1)">
                  <text
                    id="calibrationLabel"
                    x="0"
                    y="0"
                    fill="#ff6b6b"
                    font-size="40"
                    font-weight="bold"
                    text-anchor="middle"
                    style="display: none"
                  ></text>
                </g>
              </g>

              <g id="furniture" filter="url(#shadow)"></g>

              <g transform="scale(1,-1) translate(0,-5400)">
                <text
                  id="originLabel"
                  x="20"
                  y="5370"
                  fill="rgba(255,255,255,0.35)"
                  font-size="28"
                  class="mono"
                >
                  Origin: (0,0) bottom-left
                </text>
              </g>
            </g>
          </svg>
        </div>
      </main>
    </div>

    <!-- Calibration Modal -->
    <div id="calibrationModal" class="modal-overlay">
      <div class="modal">
        <h3>üìè Enter Measurement</h3>
        <p>
          You drew a line on the floor plan. Enter the real-world length of this
          line in millimetres to calibrate the scale.
        </p>
        <p id="pixelLengthInfo" class="mono" style="color: var(--muted)"></p>
        <label style="margin-top: 0">Length in mm:</label>
        <input
          type="number"
          id="calibrationMeasurement"
          placeholder="e.g., 3000"
          min="1"
        />
        <div class="modal-buttons">
          <button id="cancelCalibration">Cancel</button>
          <button
            id="confirmCalibration"
            style="background: rgba(100, 180, 255, 0.3)"
          >
            Calibrate
          </button>
        </div>
      </div>
    </div>

    <script>
      (() => {
        const svg = document.getElementById('svg');
        const world = document.getElementById('world');
        const furnitureGroup = document.getElementById('furniture');
        const zoom = document.getElementById('zoom');
        const resetBtn = document.getElementById('reset');
        const snapBtn = document.getElementById('snap');
        const toggleGridBtn = document.getElementById('toggleGrid');
        const gridLayer = document.getElementById('gridLayer');
        const layoutSelect = document.getElementById('layoutSelect');
        const saveLayoutBtn = document.getElementById('saveLayout');
        const saveAsLayoutBtn = document.getElementById('saveAsLayout');
        const deleteLayoutBtn = document.getElementById('deleteLayout');
        const itemsList = document.getElementById('itemsList');
        const addItemBtn = document.getElementById('addItem');

        // Floor plan elements
        const floorplanInput = document.getElementById('floorplanInput');
        const floorplanImage = document.getElementById('floorplanImage');
        const floorplanLayer = document.getElementById('floorplanLayer');
        const calibrateBtn = document.getElementById('calibrateBtn');
        const clearFloorplanBtn = document.getElementById('clearFloorplanBtn');
        const calibrationInfo = document.getElementById('calibrationInfo');
        const calibrationStatus = document.getElementById('calibrationStatus');
        const calibrationDetails =
          document.getElementById('calibrationDetails');
        const floorplanOpacity = document.getElementById('floorplanOpacity');
        const opacityValue = document.getElementById('opacityValue');
        const floorplansList = document.getElementById('floorplansList');
        const toggleFloorplanBtn = document.getElementById('toggleFloorplan');
        const canvasBorder = document.getElementById('canvasBorder');
        const originLabel = document.getElementById('originLabel');

        // Calibration elements
        const calibrationLayer = document.getElementById('calibrationLayer');
        const calibrationLine = document.getElementById('calibrationLine');
        const calibrationStart = document.getElementById('calibrationStart');
        const calibrationEnd = document.getElementById('calibrationEnd');
        const calibrationLabel = document.getElementById('calibrationLabel');
        const calibrationLabelGroup = document.getElementById(
          'calibrationLabelGroup'
        );
        const calibrationModal = document.getElementById('calibrationModal');
        const calibrationMeasurement = document.getElementById(
          'calibrationMeasurement'
        );
        const pixelLengthInfo = document.getElementById('pixelLengthInfo');
        const cancelCalibrationBtn =
          document.getElementById('cancelCalibration');
        const confirmCalibrationBtn =
          document.getElementById('confirmCalibration');

        let BOUNDS = { w: 3000, h: 5400 };
        const STORAGE_KEY = 'alfresco-layouts';
        const FLOORPLANS_KEY = 'floorplan-images';

        let items = [];
        let snapOn = false;
        let gridOn = true;
        let dragging = null;
        let dragOffset = { x: 0, y: 0 };
        let nextCustomId = 1;

        // Floor plan state
        let currentFloorplan = null; // { name, dataUrl, calibration: { mmPerPixel }, imageWidth, imageHeight }
        let floorplanVisible = true;
        let isCalibrating = false;
        let calibrationPoints = { start: null, end: null };
        let calibrationPixelLength = 0;

        // Panning state
        let isPanning = false;
        let spaceHeld = false;
        let panStart = { x: 0, y: 0 };
        let panOffset = { x: 0, y: 0 };

        // Helper: Convert mm to pixels based on calibration
        function mmToPixels(mm) {
          if (
            currentFloorplan &&
            currentFloorplan.calibration &&
            currentFloorplan.calibration.mmPerPixel
          ) {
            return mm / currentFloorplan.calibration.mmPerPixel;
          }
          return mm; // No calibration, assume 1:1
        }

        // Helper: Convert pixels to mm based on calibration
        function pixelsToMm(pixels) {
          if (
            currentFloorplan &&
            currentFloorplan.calibration &&
            currentFloorplan.calibration.mmPerPixel
          ) {
            return pixels * currentFloorplan.calibration.mmPerPixel;
          }
          return pixels; // No calibration, assume 1:1
        }

        // Layout management
        function getLayouts() {
          const data = localStorage.getItem(STORAGE_KEY);
          return data ? JSON.parse(data) : {};
        }

        function saveLayouts(layouts) {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(layouts));
        }

        function updateLayoutSelect() {
          const layouts = getLayouts();
          layoutSelect.innerHTML =
            '<option value="">-- Select a layout --</option>';
          Object.keys(layouts)
            .sort()
            .forEach((name) => {
              const opt = document.createElement('option');
              opt.value = name;
              opt.textContent = name;
              layoutSelect.appendChild(opt);
            });
        }

        function loadLayout(name) {
          const layouts = getLayouts();
          if (layouts[name]) {
            items = JSON.parse(JSON.stringify(layouts[name]));
            renderFurniture();
            renderItemsList();
          }
        }

        function saveCurrentLayout(name) {
          const layouts = getLayouts();
          layouts[name] = JSON.parse(JSON.stringify(items));
          saveLayouts(layouts);
          updateLayoutSelect();
          layoutSelect.value = name;
        }

        function deleteLayout(name) {
          const layouts = getLayouts();
          delete layouts[name];
          saveLayouts(layouts);
          updateLayoutSelect();
        }

        layoutSelect.addEventListener('change', () => {
          if (layoutSelect.value) {
            loadLayout(layoutSelect.value);
          }
        });

        saveLayoutBtn.addEventListener('click', () => {
          if (layoutSelect.value) {
            saveCurrentLayout(layoutSelect.value);
            alert(`Layout "${layoutSelect.value}" saved!`);
          } else {
            alert('Please select a layout first, or use "Save As New"');
          }
        });

        saveAsLayoutBtn.addEventListener('click', () => {
          const name = prompt('Enter layout name:');
          if (name && name.trim()) {
            saveCurrentLayout(name.trim());
            alert(`Layout "${name.trim()}" saved!`);
          }
        });

        deleteLayoutBtn.addEventListener('click', () => {
          if (layoutSelect.value) {
            if (confirm(`Delete layout "${layoutSelect.value}"?`)) {
              deleteLayout(layoutSelect.value);
              layoutSelect.value = '';
            }
          }
        });

        // ========== FLOOR PLAN MANAGEMENT ==========

        function getFloorplans() {
          const data = localStorage.getItem(FLOORPLANS_KEY);
          return data ? JSON.parse(data) : {};
        }

        function saveFloorplans(floorplans) {
          localStorage.setItem(FLOORPLANS_KEY, JSON.stringify(floorplans));
        }

        function saveCurrentFloorplan(name) {
          if (!currentFloorplan || !currentFloorplan.dataUrl) {
            alert('No floor plan image loaded');
            return;
          }
          const floorplans = getFloorplans();
          floorplans[name] = {
            dataUrl: currentFloorplan.dataUrl,
            calibration: currentFloorplan.calibration || null,
            imageWidth: currentFloorplan.imageWidth,
            imageHeight: currentFloorplan.imageHeight,
          };
          saveFloorplans(floorplans);
          currentFloorplan.name = name;
          renderFloorplansList();
          updateCalibrationUI();
        }

        function loadFloorplan(name) {
          const floorplans = getFloorplans();
          if (floorplans[name]) {
            const fp = floorplans[name];
            currentFloorplan = {
              name: name,
              dataUrl: fp.dataUrl,
              calibration: fp.calibration || null,
              imageWidth: fp.imageWidth,
              imageHeight: fp.imageHeight,
            };

            // Set canvas to image dimensions
            if (fp.imageWidth && fp.imageHeight) {
              updateCanvasDimensions(fp.imageWidth, fp.imageHeight);
            }

            displayFloorplanImage();
            updateCalibrationUI();
            renderFurniture(); // Re-render with new scale
          }
        }

        function deleteFloorplan(name) {
          if (confirm(`Delete floor plan "${name}"?`)) {
            const floorplans = getFloorplans();
            delete floorplans[name];
            saveFloorplans(floorplans);

            if (currentFloorplan && currentFloorplan.name === name) {
              clearFloorplan();
            }
            renderFloorplansList();
          }
        }

        function clearFloorplan() {
          currentFloorplan = null;
          floorplanImage.style.display = 'none';
          floorplanImage.removeAttribute('href');
          floorplanImage.removeAttributeNS(
            'http://www.w3.org/1999/xlink',
            'href'
          );
          updateCalibrationUI();
          renderFurniture(); // Re-render without scale
        }

        function displayFloorplanImage() {
          if (!currentFloorplan || !currentFloorplan.dataUrl) return;

          // Set both href attributes for browser compatibility
          floorplanImage.setAttribute('href', currentFloorplan.dataUrl);
          floorplanImage.setAttributeNS(
            'http://www.w3.org/1999/xlink',
            'href',
            currentFloorplan.dataUrl
          );
          floorplanImage.setAttribute('width', BOUNDS.w);
          floorplanImage.setAttribute('height', BOUNDS.h);
          floorplanImage.setAttribute('x', 0);
          floorplanImage.setAttribute('y', 0);
          floorplanImage.style.display = floorplanVisible ? '' : 'none';
          floorplanImage.setAttribute('opacity', floorplanOpacity.value);

          // Update the layer transform for current bounds
          floorplanLayer.setAttribute(
            'transform',
            `scale(1,-1) translate(0,-${BOUNDS.h})`
          );
        }

        function loadImageAndSetCanvas(dataUrl) {
          return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
              currentFloorplan = {
                name: null,
                dataUrl: dataUrl,
                calibration: null,
                imageWidth: img.naturalWidth,
                imageHeight: img.naturalHeight,
              };

              // Set canvas to match image pixel dimensions
              updateCanvasDimensions(img.naturalWidth, img.naturalHeight);
              displayFloorplanImage();
              updateCalibrationUI();
              renderFurniture();
              resolve();
            };
            img.onerror = () => {
              alert('Failed to load image');
              reject(new Error('Image load failed'));
            };
            img.src = dataUrl;
          });
        }

        function renderFloorplansList() {
          const floorplans = getFloorplans();
          floorplansList.innerHTML = '';

          const names = Object.keys(floorplans).sort();
          if (names.length === 0) {
            floorplansList.innerHTML =
              '<div style="color: var(--muted); font-size: 12px; padding: 8px;">No saved floor plans</div>';
            return;
          }

          names.forEach((name) => {
            const div = document.createElement('div');
            div.classList.add('floorplan-item');

            const isActive = currentFloorplan && currentFloorplan.name === name;
            if (isActive) {
              div.style.borderLeft = '3px solid #64b4ff';
            }

            const nameSpan = document.createElement('span');
            nameSpan.classList.add('fp-name');
            nameSpan.textContent = name;
            nameSpan.title = name;

            const actions = document.createElement('div');
            actions.classList.add('fp-actions');

            const loadBtn = document.createElement('button');
            loadBtn.textContent = 'üìÇ';
            loadBtn.title = 'Load';
            loadBtn.addEventListener('click', () => loadFloorplan(name));

            const delBtn = document.createElement('button');
            delBtn.textContent = 'üóë';
            delBtn.classList.add('danger');
            delBtn.title = 'Delete';
            delBtn.addEventListener('click', () => deleteFloorplan(name));

            actions.appendChild(loadBtn);
            actions.appendChild(delBtn);

            div.appendChild(nameSpan);
            div.appendChild(actions);
            floorplansList.appendChild(div);
          });
        }

        function updateCalibrationUI() {
          if (!currentFloorplan) {
            calibrationStatus.textContent = 'No floor plan loaded';
            calibrationStatus.classList.remove('calibrated');
            calibrationDetails.innerHTML = '';
            calibrationInfo.classList.remove('active');
            return;
          }

          if (
            currentFloorplan.calibration &&
            currentFloorplan.calibration.mmPerPixel
          ) {
            calibrationStatus.textContent = '‚úì Floor plan calibrated';
            calibrationStatus.classList.add('calibrated');
            const mpp = currentFloorplan.calibration.mmPerPixel;
            calibrationDetails.innerHTML = `
              <div class="mono" style="font-size: 10px; margin-top: 4px;">
                Scale: ${mpp.toFixed(4)} mm/pixel<br>
                1000mm = ${(1000 / mpp).toFixed(1)} pixels<br>
                Image: ${currentFloorplan.imageWidth} √ó ${
              currentFloorplan.imageHeight
            } px
              </div>
            `;
            calibrationInfo.classList.remove('active');
          } else {
            calibrationStatus.textContent = '‚ö† Floor plan not calibrated';
            calibrationStatus.classList.remove('calibrated');
            calibrationDetails.innerHTML = `<div style="font-size: 11px; margin-top: 4px;">Image: ${currentFloorplan.imageWidth} √ó ${currentFloorplan.imageHeight} px<br>Click "Calibrate Scale" to set accurate dimensions</div>`;
            calibrationInfo.classList.add('active');
          }
        }

        // ========== CANVAS DIMENSIONS ==========

        function updateCanvasDimensions(width, height) {
          BOUNDS.w = width;
          BOUNDS.h = height;

          // Update viewBox
          svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

          // Update world transform
          world.setAttribute('transform', `translate(0,${height}) scale(1,-1)`);

          // Update grid layers
          const gridRects = gridLayer.querySelectorAll('rect');
          gridRects.forEach((rect) => {
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
          });

          // Update canvas border
          canvasBorder.setAttribute('width', width);
          canvasBorder.setAttribute('height', height);

          // Update floor plan layer transform
          floorplanLayer.setAttribute(
            'transform',
            `scale(1,-1) translate(0,-${height})`
          );

          // Update floor plan image size
          floorplanImage.setAttribute('width', width);
          floorplanImage.setAttribute('height', height);

          // Update origin label position
          originLabel.setAttribute('y', height - 30);

          // Update calibration label group
          calibrationLabelGroup.setAttribute('transform', `scale(1,-1)`);
        }

        // ========== CALIBRATION ==========

        function startCalibration() {
          if (!currentFloorplan) {
            alert('Please load a floor plan image first');
            return;
          }

          isCalibrating = true;
          calibrationPoints = { start: null, end: null };
          calibrateBtn.classList.add('active');
          calibrateBtn.textContent = 'üìè Drawing line...';

          calibrationLayer.style.display = 'block';
          calibrationLine.setAttribute('x1', 0);
          calibrationLine.setAttribute('y1', 0);
          calibrationLine.setAttribute('x2', 0);
          calibrationLine.setAttribute('y2', 0);
          calibrationStart.style.display = 'none';
          calibrationEnd.style.display = 'none';
          calibrationLabel.style.display = 'none';
        }

        function endCalibration() {
          isCalibrating = false;
          calibrateBtn.classList.remove('active');
          calibrateBtn.textContent = 'üìè Calibrate Scale';
          calibrationLayer.style.display = 'none';
        }

        function showCalibrationModal() {
          pixelLengthInfo.textContent = `Line length: ${calibrationPixelLength.toFixed(
            1
          )} pixels`;
          calibrationMeasurement.value = '';
          calibrationModal.classList.add('show');
          calibrationMeasurement.focus();
        }

        function hideCalibrationModal() {
          calibrationModal.classList.remove('show');
        }

        function applyCalibration() {
          const mmLength = parseFloat(calibrationMeasurement.value);
          if (!mmLength || mmLength <= 0) {
            alert('Please enter a valid length in millimetres');
            return;
          }

          // Calculate mm per pixel based on the drawn line
          // calibrationPixelLength is in pixels (since canvas = image pixels)
          // mmLength is the real-world measurement
          const mmPerPixel = mmLength / calibrationPixelLength;

          // Store calibration info
          if (!currentFloorplan.calibration) {
            currentFloorplan.calibration = {};
          }
          currentFloorplan.calibration.mmPerPixel = mmPerPixel;
          currentFloorplan.calibration.referenceLineMm = mmLength;
          currentFloorplan.calibration.referenceLinePixels =
            calibrationPixelLength;

          hideCalibrationModal();
          endCalibration();
          updateCalibrationUI();
          renderFurniture(); // Re-render furniture with new scale

          // Auto-save if the floor plan has a name
          if (currentFloorplan.name) {
            const floorplans = getFloorplans();
            if (floorplans[currentFloorplan.name]) {
              floorplans[currentFloorplan.name].calibration =
                currentFloorplan.calibration;
              saveFloorplans(floorplans);
            }
          }

          const pixelsPer1000mm = 1000 / mmPerPixel;
          alert(
            `Calibration complete!\n\nYour line of ${calibrationPixelLength.toFixed(
              1
            )} pixels = ${mmLength}mm\n\nScale: ${mmPerPixel.toFixed(
              4
            )} mm/pixel\n1000mm = ${pixelsPer1000mm.toFixed(
              1
            )} pixels\n\nFurniture will now display at the correct scale.`
          );
        }

        function handleCalibrationClick(e) {
          if (!isCalibrating) return;

          const pt = clientToWorld(e);

          if (!calibrationPoints.start) {
            // First click - set start point
            calibrationPoints.start = { x: pt.x, y: pt.y };
            calibrationLine.setAttribute('x1', pt.x);
            calibrationLine.setAttribute('y1', pt.y);
            calibrationLine.setAttribute('x2', pt.x);
            calibrationLine.setAttribute('y2', pt.y);
            calibrationStart.setAttribute('cx', pt.x);
            calibrationStart.setAttribute('cy', pt.y);
            calibrationStart.style.display = 'block';
            calibrateBtn.textContent = 'üìè Click end point...';
          } else {
            // Second click - set end point and show modal
            calibrationPoints.end = { x: pt.x, y: pt.y };
            calibrationEnd.setAttribute('cx', pt.x);
            calibrationEnd.setAttribute('cy', pt.y);
            calibrationEnd.style.display = 'block';

            // Calculate pixel distance
            const dx = calibrationPoints.end.x - calibrationPoints.start.x;
            const dy = calibrationPoints.end.y - calibrationPoints.start.y;
            calibrationPixelLength = Math.sqrt(dx * dx + dy * dy);

            // Update label
            const midX =
              (calibrationPoints.start.x + calibrationPoints.end.x) / 2;
            const midY =
              (calibrationPoints.start.y + calibrationPoints.end.y) / 2;
            calibrationLabel.setAttribute('x', midX);
            calibrationLabel.setAttribute('y', -midY + 50);
            calibrationLabel.textContent = `${calibrationPixelLength.toFixed(
              0
            )} units`;
            calibrationLabel.style.display = 'block';

            showCalibrationModal();
          }
        }

        function handleCalibrationMove(e) {
          if (!isCalibrating || !calibrationPoints.start) return;

          const pt = clientToWorld(e);
          calibrationLine.setAttribute('x2', pt.x);
          calibrationLine.setAttribute('y2', pt.y);

          // Show live distance
          const dx = pt.x - calibrationPoints.start.x;
          const dy = pt.y - calibrationPoints.start.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          const midX = (calibrationPoints.start.x + pt.x) / 2;
          const midY = (calibrationPoints.start.y + pt.y) / 2;
          calibrationLabel.setAttribute('x', midX);
          calibrationLabel.setAttribute('y', -midY + 50);
          calibrationLabel.textContent = `${dist.toFixed(0)} px`;
          calibrationLabel.style.display = 'block';
        }

        // ========== FLOOR PLAN EVENT LISTENERS ==========

        floorplanInput.addEventListener('change', (e) => {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (evt) => {
            loadImageAndSetCanvas(evt.target.result).then(() => {
              // Prompt to save after image is loaded
              const saveName = prompt(
                'Enter a name for this floor plan (or cancel to use without saving):'
              );
              if (saveName && saveName.trim()) {
                saveCurrentFloorplan(saveName.trim());
              }
            });
          };
          reader.readAsDataURL(file);
          e.target.value = ''; // Reset input
        });

        calibrateBtn.addEventListener('click', () => {
          if (isCalibrating) {
            endCalibration();
          } else {
            startCalibration();
          }
        });

        clearFloorplanBtn.addEventListener('click', () => {
          if (confirm('Clear the current floor plan image?')) {
            clearFloorplan();
          }
        });

        floorplanOpacity.addEventListener('input', () => {
          const val = parseFloat(floorplanOpacity.value);
          opacityValue.textContent = Math.round(val * 100) + '%';
          floorplanImage.setAttribute('opacity', val);
        });

        toggleFloorplanBtn.addEventListener('click', () => {
          floorplanVisible = !floorplanVisible;
          floorplanImage.style.display = floorplanVisible ? '' : 'none';
          toggleFloorplanBtn.textContent = floorplanVisible
            ? 'Hide floor plan'
            : 'Show floor plan';
        });

        cancelCalibrationBtn.addEventListener('click', () => {
          hideCalibrationModal();
          endCalibration();
        });

        confirmCalibrationBtn.addEventListener('click', () => {
          applyCalibration();
        });

        calibrationMeasurement.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            applyCalibration();
          }
        });

        // Add calibration click handler to SVG
        svg.addEventListener('click', handleCalibrationClick);
        svg.addEventListener('mousemove', handleCalibrationMove);

        // Render furniture items to SVG
        function renderFurniture() {
          furnitureGroup.innerHTML = '';
          items.forEach((item) => {
            if (!item.visible) return;
            const g = createFurnitureElement(item);
            furnitureGroup.appendChild(g);
            if (item.rotation) {
              applyRotation(g, item);
            }
          });
        }

        function createFurnitureElement(item) {
          const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
          g.classList.add('drag');
          g.dataset.id = item.id;
          g.style.cursor = 'grab';

          if (!item.isCircle) g.dataset.rotatable = 'true';

          // Convert mm dimensions to pixels based on calibration
          const pxWidth = mmToPixels(item.width);
          const pxHeight = mmToPixels(item.isCircle ? item.width : item.height);
          const pxX = mmToPixels(item.x);
          const pxY = mmToPixels(item.y);

          let shape;
          if (item.isCircle) {
            shape = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'circle'
            );
            const r = pxWidth / 2;
            shape.setAttribute('cx', pxX + r);
            shape.setAttribute('cy', pxY + r);
            shape.setAttribute('r', r);
          } else {
            shape = document.createElementNS(
              'http://www.w3.org/2000/svg',
              'rect'
            );
            shape.setAttribute('x', pxX);
            shape.setAttribute('y', pxY);
            shape.setAttribute('width', pxWidth);
            shape.setAttribute('height', pxHeight);
            shape.setAttribute('rx', Math.min(24, pxWidth * 0.05));
          }
          shape.setAttribute('fill', item.color);
          shape.setAttribute('stroke', 'rgba(255,255,255,0.4)');
          shape.setAttribute('stroke-width', Math.max(2, mmToPixels(6)));
          g.appendChild(shape);

          // Label group - positioned at center, counter-rotated to stay upright
          const labelG = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'g'
          );
          labelG.classList.add('label');

          // Calculate center position in pixels
          const cx = item.isCircle ? pxX + pxWidth / 2 : pxX + pxWidth / 2;
          const cy = item.isCircle ? pxY + pxWidth / 2 : pxY + pxHeight / 2;

          // Font sizes based on item pixel size
          const minDim = Math.min(pxWidth, pxHeight);
          const fontSize1 = Math.min(mmToPixels(42), minDim * 0.15);
          const fontSize2 = Math.min(mmToPixels(32), minDim * 0.11);

          const text1 = document.createElementNS(
            'http://www.w3.org/2000/svg',
            'text'
          );
          text1.setAttribute('x', cx);
          text1.setAttribute('y', cy);
          text1.setAttribute('fill', 'white');
          text1.setAttribute('font-size', Math.max(10, fontSize1));
          text1.setAttribute('font-weight', '700');
          text1.setAttribute('text-anchor', 'middle');
          text1.setAttribute('dominant-baseline', 'middle');
          // Counter-rotate and flip text to appear upright (since world is flipped)
          text1.setAttribute(
            'transform',
            `scale(1,-1) translate(0, ${-2 * cy})`
          );
          text1.textContent = item.name.toUpperCase();
          labelG.appendChild(text1);

          g.appendChild(labelG);

          // Event listeners
          g.addEventListener('pointerdown', onDown);
          g.addEventListener('dblclick', onDblClick);

          return g;
        }

        function updateLabelPosition(g, item) {
          const labelG = g.querySelector('.label');
          if (!labelG) return;

          // Convert to pixels
          const pxWidth = mmToPixels(item.width);
          const pxHeight = mmToPixels(item.isCircle ? item.width : item.height);
          const pxX = mmToPixels(item.x);
          const pxY = mmToPixels(item.y);

          const cx = item.isCircle ? pxX + pxWidth / 2 : pxX + pxWidth / 2;
          const cy = item.isCircle ? pxY + pxWidth / 2 : pxY + pxHeight / 2;

          const minDim = Math.min(pxWidth, pxHeight);
          const fontSize1 = Math.min(mmToPixels(42), minDim * 0.15);

          const texts = labelG.querySelectorAll('text');
          if (texts[0]) {
            texts[0].setAttribute('x', cx);
            texts[0].setAttribute('y', cy);
            texts[0].setAttribute(
              'transform',
              `scale(1,-1) translate(0, ${-2 * cy})`
            );
          }
          if (texts[1]) {
            texts[1].setAttribute('x', cx);
            texts[1].setAttribute('y', cy + fontSize1 * 0.8);
            texts[1].setAttribute(
              'transform',
              `scale(1,-1) translate(0, ${-2 * (cy + fontSize1 * 0.8)})`
            );
          }
        }

        function applyRotation(g, item) {
          const shape = g.querySelector('rect, circle');
          if (!shape) return;

          let cx, cy;
          if (shape.tagName === 'circle') {
            cx = parseFloat(shape.getAttribute('cx'));
            cy = parseFloat(shape.getAttribute('cy'));
          } else {
            const x = parseFloat(shape.getAttribute('x'));
            const y = parseFloat(shape.getAttribute('y'));
            const w = parseFloat(shape.getAttribute('width'));
            const h = parseFloat(shape.getAttribute('height'));
            cx = x + w / 2;
            cy = y + h / 2;
          }

          if (item.rotation === 0) {
            g.removeAttribute('transform');
          } else {
            g.setAttribute('transform', `rotate(${item.rotation} ${cx} ${cy})`);
          }

          // Update label position after rotation
          updateLabelPosition(g, item);
        }

        // Render items list in sidebar
        function renderItemsList() {
          itemsList.innerHTML = '';
          items.forEach((item) => {
            const row = document.createElement('div');
            row.classList.add('item-row');
            if (!item.visible) row.classList.add('hidden-item');

            const colorInput = document.createElement('input');
            colorInput.type = 'color';
            colorInput.classList.add('item-color');
            colorInput.value = rgbaToHex(item.color);
            colorInput.addEventListener('change', () => {
              item.color = hexToRgba(colorInput.value, 0.55);
              renderFurniture();
            });

            const nameSpan = document.createElement('span');
            nameSpan.classList.add('item-name');
            nameSpan.textContent = item.name;

            const dimsSpan = document.createElement('span');
            dimsSpan.classList.add('item-dims');
            dimsSpan.textContent = item.isCircle
              ? `√ò${item.width}`
              : `${item.width}√ó${item.height}`;

            const actions = document.createElement('div');
            actions.classList.add('item-actions');

            const toggleBtn = document.createElement('button');
            toggleBtn.textContent = item.visible ? 'üëÅ' : 'üëÅ‚Äçüó®';
            toggleBtn.title = item.visible ? 'Hide' : 'Show';
            toggleBtn.addEventListener('click', () => {
              item.visible = !item.visible;
              renderFurniture();
              renderItemsList();
            });

            const deleteBtn = document.createElement('button');
            deleteBtn.textContent = 'üóë';
            deleteBtn.classList.add('danger');
            deleteBtn.title = 'Remove';
            deleteBtn.addEventListener('click', () => {
              if (confirm(`Remove "${item.name}"?`)) {
                items = items.filter((i) => i.id !== item.id);
                renderFurniture();
                renderItemsList();
              }
            });

            actions.appendChild(toggleBtn);
            actions.appendChild(deleteBtn);

            row.appendChild(colorInput);
            row.appendChild(nameSpan);
            row.appendChild(dimsSpan);
            row.appendChild(actions);
            itemsList.appendChild(row);
          });
        }

        // Color conversion helpers
        function rgbaToHex(rgba) {
          const match = rgba.match(/\d+/g);
          if (match && match.length >= 3) {
            const r = parseInt(match[0]).toString(16).padStart(2, '0');
            const g = parseInt(match[1]).toString(16).padStart(2, '0');
            const b = parseInt(match[2]).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
          }
          return '#888888';
        }

        function hexToRgba(hex, alpha = 0.55) {
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Add new item
        addItemBtn.addEventListener('click', () => {
          const name = document.getElementById('newItemName').value.trim();
          const width = parseInt(document.getElementById('newItemWidth').value);
          const height = parseInt(
            document.getElementById('newItemHeight').value
          );
          const color = hexToRgba(
            document.getElementById('newItemColor').value,
            0.55
          );
          const isCircle = document.getElementById('newItemCircle').checked;

          if (!name) {
            alert('Please enter item name');
            return;
          }
          if (!width || width < 100) {
            alert('Width must be at least 100mm');
            return;
          }
          if (!isCircle && (!height || height < 100)) {
            alert('Height must be at least 100mm');
            return;
          }

          const newItem = {
            id: `custom-${nextCustomId++}`,
            name,
            width,
            height: isCircle ? width : height,
            color,
            x: 500, // mm position
            y: 500, // mm position
            rotation: 0,
            isCircle,
            rotatable: !isCircle,
            visible: true,
          };

          items.push(newItem);
          renderFurniture();
          renderItemsList();

          // Clear form
          document.getElementById('newItemName').value = '';
          document.getElementById('newItemWidth').value = '';
          document.getElementById('newItemHeight').value = '';
          document.getElementById('newItemCircle').checked = false;
        });

        // Drag handlers
        function getShape(g) {
          return g.querySelector('rect, circle');
        }

        function getPos(shape) {
          if (shape.tagName === 'rect') {
            return {
              x: parseFloat(shape.getAttribute('x')),
              y: parseFloat(shape.getAttribute('y')),
            };
          } else {
            const cx = parseFloat(shape.getAttribute('cx'));
            const cy = parseFloat(shape.getAttribute('cy'));
            const r = parseFloat(shape.getAttribute('r'));
            return { x: cx - r, y: cy - r };
          }
        }

        function setPos(shape, x, y) {
          if (shape.tagName === 'rect') {
            shape.setAttribute('x', x);
            shape.setAttribute('y', y);
          } else {
            const r = parseFloat(shape.getAttribute('r'));
            shape.setAttribute('cx', x + r);
            shape.setAttribute('cy', y + r);
          }
        }

        function clientToWorld(evt) {
          const pt = svg.createSVGPoint();
          pt.x = evt.clientX;
          pt.y = evt.clientY;
          const ctm = world.getScreenCTM();
          if (!ctm) return { x: 0, y: 0 };
          return pt.matrixTransform(ctm.inverse());
        }

        function snap(value, step) {
          return Math.round(value / step) * step;
        }

        // Clamp position in mm coordinates
        function clampPosMm(item, xMm, yMm) {
          const rotation = item.rotation || 0;
          let w = item.width,
            h = item.height;
          if (rotation === 90 || rotation === 270) [w, h] = [h, w];

          const offsetX =
            rotation === 90 || rotation === 270
              ? (item.width - item.height) / 2
              : 0;
          const offsetY =
            rotation === 90 || rotation === 270
              ? (item.height - item.width) / 2
              : 0;

          // Get max bounds in mm
          const maxXMm = pixelsToMm(BOUNDS.w);
          const maxYMm = pixelsToMm(BOUNDS.h);

          const nx = Math.min(Math.max(-offsetX, xMm), maxXMm - w - offsetX);
          const ny = Math.min(Math.max(-offsetY, yMm), maxYMm - h - offsetY);
          return { x: nx, y: ny };
        }

        function onDown(e) {
          if (isCalibrating) return; // Don't drag while calibrating
          if (spaceHeld) return; // Don't drag furniture while panning

          const g = e.currentTarget;
          const shape = getShape(g);
          const pos = getPos(shape); // Position in pixels
          const p = clientToWorld(e); // Click position in pixels

          dragging = { g, shape, id: g.dataset.id };
          dragOffset = { x: p.x - pos.x, y: p.y - pos.y }; // Offset in pixels
          g.style.cursor = 'grabbing';
          e.preventDefault();
        }

        function onMove(e) {
          if (!dragging) return;
          const { g, shape, id } = dragging;
          const item = items.find((i) => i.id === id);
          if (!item) return;

          const p = clientToWorld(e); // Position in pixels
          let pxX = p.x - dragOffset.x;
          let pxY = p.y - dragOffset.y;

          // Convert to mm for storage and snapping
          let mmX = pixelsToMm(pxX);
          let mmY = pixelsToMm(pxY);

          if (snapOn) {
            mmX = snap(mmX, 50);
            mmY = snap(mmY, 50);
          }

          // Clamp in mm space
          const clamped = clampPosMm(item, mmX, mmY);

          // Store in mm
          item.x = clamped.x;
          item.y = clamped.y;

          // Convert back to pixels for display
          const displayPxX = mmToPixels(clamped.x);
          const displayPxY = mmToPixels(clamped.y);

          setPos(shape, displayPxX, displayPxY);
          updateLabelPosition(g, item);
          applyRotation(g, item);
        }

        function onUp() {
          if (!dragging) return;
          dragging.g.style.cursor = 'grab';
          dragging = null;
        }

        function onDblClick(e) {
          const g = e.currentTarget;
          const id = g.dataset.id;
          const item = items.find((i) => i.id === id);
          if (!item) return;

          if (g.dataset.rotatable === 'true') {
            item.rotation = ((item.rotation || 0) + 90) % 360;
            applyRotation(g, item);
            e.preventDefault();
          }
        }

        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);

        // Controls
        function applyTransform() {
          const z = parseFloat(zoom.value);
          svg.style.transformOrigin = 'center center';
          svg.style.transform = `translate(${panOffset.x}px, ${panOffset.y}px) scale(${z})`;
        }

        function applyZoom(v) {
          applyTransform();
        }

        applyTransform();
        zoom.addEventListener('input', () => applyTransform());

        // Mouse wheel zoom
        svg.addEventListener(
          'wheel',
          (e) => {
            e.preventDefault();
            const zoomStep = 0.1;
            const minZoom = parseFloat(zoom.min);
            const maxZoom = parseFloat(zoom.max);
            let currentZoom = parseFloat(zoom.value);

            if (e.deltaY < 0) {
              // Scroll up - zoom in
              currentZoom = Math.min(maxZoom, currentZoom + zoomStep);
            } else {
              // Scroll down - zoom out
              currentZoom = Math.max(minZoom, currentZoom - zoomStep);
            }

            zoom.value = currentZoom;
            applyTransform();
          },
          { passive: false }
        );

        // Space+drag panning
        function onPanStart(e) {
          if (!spaceHeld) return;
          isPanning = true;
          panStart = { x: e.clientX - panOffset.x, y: e.clientY - panOffset.y };
          svg.style.cursor = 'grabbing';
          e.preventDefault();
        }

        function onPanMove(e) {
          if (!isPanning) return;
          panOffset.x = e.clientX - panStart.x;
          panOffset.y = e.clientY - panStart.y;
          applyTransform();
        }

        function onPanEnd() {
          if (isPanning) {
            isPanning = false;
            svg.style.cursor = spaceHeld ? 'grab' : '';
          }
        }

        // Keyboard listeners for spacebar
        window.addEventListener('keydown', (e) => {
          if (e.code === 'Space' && !e.repeat && !isInputFocused()) {
            spaceHeld = true;
            svg.style.cursor = 'grab';
            e.preventDefault();
          }
        });

        window.addEventListener('keyup', (e) => {
          if (e.code === 'Space') {
            spaceHeld = false;
            isPanning = false;
            svg.style.cursor = '';
          }
        });

        // Check if an input element is focused (to allow typing spaces)
        function isInputFocused() {
          const active = document.activeElement;
          return (
            active &&
            (active.tagName === 'INPUT' ||
              active.tagName === 'TEXTAREA' ||
              active.tagName === 'SELECT')
          );
        }

        // Add pan listeners to SVG
        svg.addEventListener('mousedown', onPanStart);
        window.addEventListener('mousemove', onPanMove);
        window.addEventListener('mouseup', onPanEnd);

        resetBtn.addEventListener('click', () => {
          items = [];
          renderFurniture();
          renderItemsList();
        });

        snapBtn.addEventListener('click', () => {
          snapOn = !snapOn;
          snapBtn.textContent = snapOn ? 'Snap: ON (50mm)' : 'Snap to 50mm';
        });

        toggleGridBtn.addEventListener('click', () => {
          gridOn = !gridOn;
          gridLayer.style.display = gridOn ? 'block' : 'none';
        });

        // Initialize
        updateLayoutSelect();
        renderFurniture();
        renderItemsList();
        renderFloorplansList();
        updateCalibrationUI();
      })();
    </script>
  </body>
</html>
